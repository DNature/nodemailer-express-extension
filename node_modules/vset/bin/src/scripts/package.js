/// <reference path="../../typings/tsd.d.ts" />
var _ = require("lodash");
var defaultManifest = require("./default-manifest");
var childProcess = require("child_process");
var fs = require("fs");
var glob = require("glob");
var loc = require("./loc");
var log = require("./logger");
var onecolor = require("onecolor");
var os = require("os");
var path = require("path");
var program = require("commander");
var Q = require("q");
var winreg = require("winreg");
var xml = require("xml2js");
var zip = require("jszip");
var mkdirp = require('mkdirp');
var Package;
(function (Package) {
    var Merger = (function () {
        function Merger(settings) {
            this.mergeSettings = {
                root: settings.root,
                manifestGlobs: settings.manifestGlobs,
                overrides: settings.overrides
            };
        }
        Merger.prototype.gatherManifests = function () {
            var _this = this;
            var globPatterns = this.mergeSettings.manifestGlobs;
            var globs = globPatterns.map(function (pattern) {
                return path.isAbsolute(pattern) ? pattern : path.join(_this.mergeSettings.root, pattern);
            });
            return Q.all(globs.map(function (pattern) { return _this.gatherManifestsFromGlob(pattern); })).then(function (fileLists) {
                return _.unique(fileLists.reduce(function (a, b) { return a.concat(b); }));
            }).then(function (paths) {
                if (paths.length > 0) {
                    log.info("Merging %s manifests from the following paths: ", 2, paths.length.toString());
                    paths.forEach(function (path) { return log.info(path, 3); });
                    return paths;
                }
                else {
                    throw "No manifests found from the following glob patterns: \n" + globPatterns.join("\n");
                }
            });
        };
        Merger.prototype.gatherManifestsFromGlob = function (globPattern) {
            return Q.Promise(function (resolve, reject, notify) {
                glob(globPattern, function (err, matches) {
                    if (!err) {
                        resolve(matches);
                    }
                    else {
                        reject(err);
                    }
                });
            });
        };
        Merger.prototype.merge = function () {
            var _this = this;
            return this.gatherManifests().then(function (files) {
                var overridesProvided = false;
                var manifestPromises = [];
                files.forEach(function (file) {
                    manifestPromises.push(Q.nfcall(fs.readFile, file, "utf8").then(function (data) {
                        var jsonData = data.replace(/^\uFEFF/, '');
                        try {
                            var result = JSON.parse(jsonData);
                            result.__origin = file;
                            return result;
                        }
                        catch (err) {
                            log.error("Error parsing the JSON in %s: ", file);
                            log.info(jsonData, null);
                            throw err;
                        }
                    }));
                    if (_this.mergeSettings.overrides) {
                        overridesProvided = true;
                        manifestPromises.push(Q.resolve(_this.mergeSettings.overrides));
                    }
                });
                var vsixManifest = JSON.parse(JSON.stringify(defaultManifest.defaultManifest));
                vsixManifest.__meta_root = _this.mergeSettings.root;
                var vsoManifest = {
                    __meta_root: _this.mergeSettings.root,
                    scopes: [],
                    contributions: [],
                };
                var packageFiles = {};
                return Q.all(manifestPromises).then(function (partials) {
                    partials.forEach(function (partial, partialIndex) {
                        if (_.isArray(partial["files"])) {
                            partial["files"].forEach(function (asset) {
                                var keys = Object.keys(asset);
                                if (keys.indexOf("path") < 0) {
                                    throw "Files must have an absolute or relative (to the manifest) path.";
                                }
                                var absolutePath;
                                if (path.isAbsolute(asset.path)) {
                                    absolutePath = asset.path;
                                }
                                else {
                                    absolutePath = path.join(path.dirname(partial.__origin), asset.path);
                                }
                                asset.path = path.relative(_this.mergeSettings.root, absolutePath);
                            });
                        }
                        if (_.isObject(partial["icons"])) {
                            var icons = partial["icons"];
                            Object.keys(icons).forEach(function (iconKind) {
                                var absolutePath = path.join(path.dirname(partial.__origin), icons[iconKind]);
                                icons[iconKind] = path.relative(_this.mergeSettings.root, absolutePath);
                            });
                        }
                        var pathToFileDeclarations = function (fsPath, root, addressable) {
                            var files = [];
                            if (fs.lstatSync(fsPath).isDirectory()) {
                                log.debug("Path '%s` is a directory. Adding all contained files (recursive).", fsPath);
                                fs.readdirSync(fsPath).forEach(function (dirChildPath) {
                                    log.debug("-- %s", dirChildPath);
                                    files = files.concat(pathToFileDeclarations(path.join(fsPath, dirChildPath), root, addressable));
                                });
                            }
                            else {
                                var relativePath = path.relative(root, fsPath);
                                files.push({ path: relativePath, partName: relativePath, auto: true, addressable: addressable });
                            }
                            return files;
                        };
                        if (_.isArray(partial["files"])) {
                            for (var i = partial["files"].length - 1; i >= 0; --i) {
                                var fileDecl = partial["files"][i];
                                var fsPath = path.join(vsoManifest.__meta_root, fileDecl.path);
                                if (fs.lstatSync(fsPath).isDirectory()) {
                                    Array.prototype.splice.apply(partial["files"], [i, 1].concat(pathToFileDeclarations(fsPath, vsoManifest.__meta_root, fileDecl.addressable)));
                                }
                            }
                        }
                        Object.keys(partial).forEach(function (key) {
                            _this.mergeKey(key, partial[key], vsoManifest, vsixManifest, packageFiles, partials.length - 1 === partialIndex && overridesProvided);
                        });
                    });
                    var vsoDefaults = {
                        manifestVersion: 1.0
                    };
                    Object.keys(vsoDefaults).forEach(function (d) {
                        if (!vsoManifest[d]) {
                            vsoManifest[d] = vsoDefaults[d];
                        }
                    });
                    var installationTarget = _.get(vsixManifest, "PackageManifest.Installation[0].InstallationTarget");
                    if (!(_.isArray(installationTarget) && installationTarget.length > 0)) {
                        log.warn("No 'target' provided. Defaulting to Microsoft.VisualStudio.Services.");
                        _.set(vsixManifest, "PackageManifest.Installation[0].InstallationTarget", [
                            {
                                $: {
                                    Id: "Microsoft.VisualStudio.Services"
                                }
                            }
                        ]);
                    }
                    var locPrepper = new loc.LocPrep.LocKeyGenerator(vsoManifest, vsixManifest);
                    var extractedResources = locPrepper.generateLocalizationKeys();
                    var validationResult = _this.validateVsixJson(vsixManifest);
                    log.debug("VSO Manifest: " + JSON.stringify(vsoManifest, null, 4));
                    log.debug("VSIX Manifest: " + JSON.stringify(vsixManifest, null, 4));
                    if (validationResult.length === 0 || program["bypassValidation"]) {
                        return {
                            vsoManifest: vsoManifest,
                            vsixManifest: vsixManifest,
                            files: packageFiles,
                            resources: extractedResources
                        };
                    }
                    else {
                        throw "There were errors with your manifests. Address the following errors and re-run the tool.\n" + validationResult;
                    }
                });
            });
        };
        Merger.prototype.handleDelimitedList = function (value, object, path, delimiter, uniq) {
            if (delimiter === void 0) { delimiter = ","; }
            if (uniq === void 0) { uniq = true; }
            if (_.isString(value)) {
                value = value.split(delimiter);
                _.remove(value, function (v) { return v === ""; });
            }
            var items = _.get(object, path, "").split(delimiter);
            _.remove(items, function (v) { return v === ""; });
            var val = items.concat(value);
            if (uniq) {
                val = _.uniq(val);
            }
            _.set(object, path, val.join(delimiter));
        };
        Merger.prototype.singleValueProperty = function (obj, path, value, manifestKey, override) {
            if (override === void 0) { override = false; }
            var existingValue = _.get(obj, path);
            if (!override && existingValue !== undefined) {
                log.warn("Multiple values found for '%s'. Ignoring future occurrences and using the value '%s'.", manifestKey, JSON.stringify(existingValue, null, 4));
                return false;
            }
            else {
                _.set(obj, path, value);
                return true;
            }
        };
        Merger.cleanAssetPath = function (assetPath) {
            var cleanPath = assetPath.replace(/\\/g, "/");
            if (!_.startsWith(cleanPath, "/")) {
                cleanPath = "/" + cleanPath;
            }
            return cleanPath;
        };
        Merger.prototype.addFile = function (file, packageFiles) {
            if (!file.partName) {
                file.partName = file.path;
            }
            if (!file.auto || !packageFiles[file.path]) {
                packageFiles[file.path] = {
                    partName: file.partName || file.path
                };
            }
            if (file.contentType) {
                packageFiles[file.path].contentType = file.contentType;
            }
        };
        Merger.prototype.addAsset = function (file, manifest, packageFiles) {
            file.path = Merger.cleanAssetPath(file.path);
            if (file.addressable && !file.assetType) {
                file.assetType = VsixWriter.toZipItemName(file.path);
            }
            this.addFile(file, packageFiles);
            if (file.assetType) {
                this.addAssetToManifest(manifest, file.path, file.assetType, file.addressable, file.lang);
            }
        };
        Merger.prototype.addProperty = function (vsixManifest, id, value) {
            var defaultProperties = [];
            var existingProperties = _.get(vsixManifest, "PackageManifest.Metadata[0].Properties[0].Property", defaultProperties);
            if (defaultProperties === existingProperties) {
                _.set(vsixManifest, "PackageManifest.Metadata[0].Properties[0].Property", defaultProperties);
            }
            existingProperties.push({
                $: {
                    Id: id,
                    Value: value
                }
            });
        };
        Merger.prototype.addAssetToManifest = function (manifest, assetPath, type, addressable, lang) {
            if (addressable === void 0) { addressable = false; }
            if (lang === void 0) { lang = null; }
            var cleanAssetPath = VsixWriter.toZipItemName(assetPath);
            var asset = {
                "Type": type,
                "d:Source": "File",
                "Path": cleanAssetPath
            };
            if (addressable) {
                asset["Addressable"] = "true";
            }
            if (lang) {
                asset["Lang"] = lang;
            }
            manifest.PackageManifest.Assets[0].Asset.push({
                "$": asset
            });
            if (type === "Microsoft.VisualStudio.Services.Icons.Default") {
                manifest.PackageManifest.Metadata[0].Icon = [cleanAssetPath];
            }
            if (type === "Microsoft.VisualStudio.Services.Content.License") {
                manifest.PackageManifest.Metadata[0].License = [cleanAssetPath];
            }
        };
        Merger.prototype.mergeKey = function (key, value, vsoManifest, vsixManifest, packageFiles, override) {
            var _this = this;
            switch (key.toLowerCase()) {
                case "namespace":
                case "extensionid":
                case "id":
                    if (_.isString(value)) {
                        this.singleValueProperty(vsixManifest, "PackageManifest.Metadata[0].Identity[0].$.Id", value, "namespace/extensionId/id", override);
                    }
                    break;
                case "version":
                    this.singleValueProperty(vsixManifest, "PackageManifest.Metadata[0].Identity[0].$.Version", value, key, override);
                    break;
                case "name":
                    this.singleValueProperty(vsixManifest, "PackageManifest.Metadata[0].DisplayName[0]", value, key, override);
                    break;
                case "description":
                    this.singleValueProperty(vsixManifest, "PackageManifest.Metadata[0].Description[0]._", value, key, override);
                    break;
                case "eventcallbacks":
                    if (_.isObject(value)) {
                        if (!vsoManifest.eventCallbacks) {
                            vsoManifest.eventCallbacks = {};
                        }
                        _.merge(vsoManifest.eventCallbacks, value);
                    }
                    break;
                case "icons":
                    Object.keys(value).forEach(function (key) {
                        var iconType = _.startCase(key.toLowerCase());
                        var fileDecl = {
                            path: value[key],
                            addressable: true,
                            assetType: "Microsoft.VisualStudio.Services.Icons." + iconType,
                            partName: value[key]
                        };
                        _this.addAsset(fileDecl, vsixManifest, packageFiles);
                    });
                    break;
                case "screenshots":
                    if (_.isArray(value)) {
                        var screenshotIndex_1 = 0;
                        value.forEach(function (screenshot) {
                            var fileDecl = {
                                path: screenshot.path,
                                addressable: true,
                                assetType: "Microsoft.VisualStudio.Services.Screenshots." + (++screenshotIndex_1),
                                contentType: screenshot.contentType
                            };
                            _this.addAsset(fileDecl, vsixManifest, packageFiles);
                        });
                    }
                    break;
                case "content":
                    Object.keys(value).forEach(function (key) {
                        var contentKey = _.startCase(key.toLowerCase());
                        if (value[key].path) {
                            var fileDecl = {
                                path: value[key].path,
                                addressable: true,
                                assetType: "Microsoft.VisualStudio.Services.Content." + contentKey,
                                partName: value[key].path
                            };
                            if (value[key].contentType) {
                                fileDecl.contentType = value[key].contentType;
                            }
                            _this.addAsset(fileDecl, vsixManifest, packageFiles);
                        }
                        else {
                            log.warn("Did not find 'path' property for content item '%s'. Ignoring.", key);
                        }
                    });
                    break;
                case "manifestversion":
                    var version = value;
                    if (_.isString(version)) {
                        version = parseFloat(version);
                    }
                    if (!version) {
                        version = 1;
                    }
                    this.singleValueProperty(vsoManifest, "manifestVersion", version, key, override);
                    break;
                case "targets":
                    if (_.isArray(value)) {
                        var existingTargets = _.get(vsixManifest, "PackageManifest.Installation[0].InstallationTarget", []);
                        value.forEach(function (target) {
                            if (!target.id) {
                                return;
                            }
                            var newTargetAttrs = {
                                Id: target.id
                            };
                            if (target.version) {
                                newTargetAttrs["Version"] = target.version;
                            }
                            existingTargets.push({
                                $: newTargetAttrs
                            });
                        });
                    }
                    break;
                case "links":
                    if (_.isObject(value)) {
                        Object.keys(value).forEach(function (linkType) {
                            var url = _.get(value, linkType + ".uri") || _.get(value, linkType + ".url");
                            if (url) {
                                var linkTypeCased = _.capitalize(_.camelCase(linkType));
                                _this.addProperty(vsixManifest, "Microsoft.VisualStudio.Services.Links." + linkTypeCased, url);
                            }
                            else {
                                log.warn("'uri' property not found for link: '%s'... ignoring.", linkType);
                            }
                        });
                    }
                    break;
                case "branding":
                    if (_.isObject(value)) {
                        Object.keys(value).forEach(function (brandingType) {
                            var brandingTypeCased = _.capitalize(_.camelCase(brandingType));
                            var brandingValue = value[brandingType];
                            if (brandingTypeCased === "Color") {
                                try {
                                    brandingValue = onecolor(brandingValue).hex();
                                }
                                catch (e) {
                                    throw "Could not parse branding color as a valid color. Please use a hex or rgb format, e.g. #00ff00 or rgb(0, 255, 0)";
                                }
                            }
                            _this.addProperty(vsixManifest, "Microsoft.VisualStudio.Services.Branding." + brandingTypeCased, brandingValue);
                        });
                    }
                    break;
                case "public":
                    if (typeof value === "boolean") {
                        var flags = _.get(vsixManifest, "PackageManifest.Metadata[0].GalleryFlags[0]", "").split(",");
                        _.remove(flags, function (v) { return v === ""; });
                        if (value === true) {
                            flags.push("Public");
                        }
                        _.set(vsixManifest, "PackageManifest.Metadata[0].GalleryFlags[0]", _.uniq(flags).join(","));
                    }
                    break;
                case "publisher":
                    this.singleValueProperty(vsixManifest, "PackageManifest.Metadata[0].Identity[0].$.Publisher", value, key, override);
                    break;
                case "longdescription":
                    this.singleValueProperty(vsixManifest, "PackageManifest.Metadata[0].ReleaseNotes[0]", value, key, override);
                    this.singleValueProperty(vsixManifest, "PackageManifest.Metadata[0].LongDescription[0]", value, key, override);
                    break;
                case "scopes":
                    if (_.isArray(value)) {
                        vsoManifest.scopes = _.uniq(vsoManifest.scopes.concat(value));
                    }
                    break;
                case "tags":
                    this.handleDelimitedList(value, vsixManifest, "PackageManifest.Metadata[0].Tags[0]");
                    break;
                case "flags":
                case "vsoflags":
                case "galleryflags":
                    this.handleDelimitedList(value, vsixManifest, "PackageManifest.Metadata[0].GalleryFlags[0]", " ");
                    break;
                case "categories":
                    this.handleDelimitedList(value, vsixManifest, "PackageManifest.Metadata[0].Categories[0]");
                    break;
                case "baseuri":
                case "baseurl":
                    this.singleValueProperty(vsoManifest, "baseUri", value, key, override);
                    break;
                case "contributions":
                    if (_.isArray(value)) {
                        vsoManifest.contributions = vsoManifest.contributions.concat(value);
                    }
                    break;
                case "contributiontypes":
                    if (_.isArray(value)) {
                        if (!vsoManifest.contributionTypes) {
                            vsoManifest.contributionTypes = [];
                        }
                        vsoManifest.contributionTypes = vsoManifest.contributionTypes.concat(value);
                    }
                    break;
                case "screenshots":
                    if (_.isArray(value)) {
                        var screenshotIndex = 1;
                        value.forEach(function (asset) {
                            var assetPath = asset.path.replace(/\\/g, "/");
                            if (!packageFiles[assetPath]) {
                                packageFiles[assetPath] = {
                                    partName: assetPath
                                };
                            }
                            if (asset.contentType) {
                                packageFiles[assetPath].contentType = asset.contentType;
                            }
                            vsixManifest.PackageManifest.Assets[0].Asset.push({
                                "$": {
                                    "Type": "Microsoft.VisualStudio.Services.Screenshots." + (screenshotIndex++),
                                    "d:Source": "File",
                                    "Path": assetPath,
                                    "Addressable": "true"
                                }
                            });
                        });
                    }
                    break;
                case "files":
                    if (_.isArray(value)) {
                        value.forEach(function (asset) {
                            _this.addAsset(asset, vsixManifest, packageFiles);
                        });
                    }
                    break;
                default:
                    if (key.substr(0, 2) !== "__") {
                        this.singleValueProperty(vsoManifest, key, value, key, override);
                    }
                    break;
            }
        };
        Merger.prototype.validateVsixJson = function (vsixManifest) {
            return Object.keys(Merger.vsixValidators).map(function (path) { return Merger.vsixValidators[path](_.get(vsixManifest, path)); }).filter(function (r) { return !!r; });
        };
        Merger.ICON_TYPES = ["Default", "Wide", "Small", "Large"];
        Merger.vsixValidators = {
            "PackageManifest.Metadata[0].Identity[0].$.Id": function (value) {
                if (/^[A-z0-9_-]+$/.test(value)) {
                    return null;
                }
                else {
                    return "'extensionId' may only include letters, numbers, underscores, and dashes.";
                }
            },
            "PackageManifest.Metadata[0].Identity[0].$.Version": function (value) {
                if (typeof value === "string" && value.length > 0) {
                    return null;
                }
                else {
                    return "'version' must be provided.";
                }
            },
            "PackageManifest.Metadata[0].DisplayName[0]": function (value) {
                if (typeof value === "string" && value.length > 0) {
                    return null;
                }
                else {
                    return "'name' must be provided.";
                }
            },
            "PackageManifest.Assets[0].Asset": function (value) {
                var usedAssetTypes = {};
                if (_.isArray(value)) {
                    for (var i = 0; i < value.length; ++i) {
                        var asset = value[i].$;
                        if (asset) {
                            if (!asset.Path) {
                                return "All 'files' must include a 'path'.";
                            }
                            if (asset.Type && asset.Addressable) {
                                if (usedAssetTypes[asset.Type]) {
                                    return "Cannot have multiple 'addressable' files with the same 'assetType'.\nFile1: " + usedAssetTypes[asset.Type] + ", File 2: " + asset.Path + " (asset type: " + asset.Type + ")";
                                }
                                else {
                                    usedAssetTypes[asset.Type] = asset.Path;
                                }
                            }
                        }
                    }
                }
                return null;
            },
            "PackageManifest.Metadata[0].Identity[0].$.Publisher": function (value) {
                if (typeof value === "string" && value.length > 0) {
                    return null;
                }
                else {
                    return "'publisher' must be provided.";
                }
            },
            "PackageManifest.Metadata[0].Categories[0]": function (value) {
                if (!value) {
                    return null;
                }
                var categories = value.split(",");
                if (categories.length > 1) {
                    return "For now, extensions are limited to a single category.";
                }
                var validCategories = [
                    "Administration",
                    "Build and release",
                    "Code",
                    "Collaborate",
                    "Developer samples",
                    "Insights",
                    "Integrate",
                    "Plan and track",
                    "Other",
                    "Test"
                ];
                _.remove(categories, function (c) { return !c; });
                var badCategories = categories.filter(function (c) { return validCategories.indexOf(c) < 0; });
                return badCategories.length ? "The following categories are not valid: " + badCategories.join(", ") + ". Valid categories are: " + validCategories.join(", ") + "." : null;
            },
            "PackageManifest.Installation[0].InstallationTarget": function (value) {
                if (_.isArray(value) && value.length > 0) {
                    return null;
                }
                return "Your manifest must include at least one 'target'.";
            }
        };
        return Merger;
    })();
    Package.Merger = Merger;
    var VsixWriter = (function () {
        function VsixWriter(settings, components) {
            this.settings = settings;
            this.vsoManifest = components.vsoManifest;
            this.vsixManifest = components.vsixManifest;
            this.files = components.files;
            this.resources = components.resources;
            this.prepManifests();
        }
        VsixWriter.prototype.prepManifests = function () {
            var assets = _.get(this.vsixManifest, "PackageManifest.Assets[0].Asset");
            if (assets) {
                _.remove(assets, function (asset) {
                    var type = _.get(asset, "$.Type", "x").toLowerCase();
                    return type === "microsoft.vso.manifest" || type === "microsoft.visualstudio.services.manifest";
                });
            }
            else {
                assets = [];
                _.set(this.vsixManifest, "PackageManifest.Assets[0].Asset[0]", assets);
            }
            assets.push({ $: {
                    Type: "Microsoft.VisualStudio.Services.Manifest",
                    Path: VsixWriter.VSO_MANIFEST_FILENAME,
                    Addressable: "true",
                    "d:Source": "File"
                } });
            log.debug("Manifests finished prepping.");
        };
        VsixWriter.prototype.getOutputPath = function (outPath) {
            var newPath = outPath;
            var pub = _.get(this.vsixManifest, "PackageManifest.Metadata[0].Identity[0].$.Publisher");
            var ns = _.get(this.vsixManifest, "PackageManifest.Metadata[0].Identity[0].$.Id");
            var version = _.get(this.vsixManifest, "PackageManifest.Metadata[0].Identity[0].$.Version");
            var autoName = pub + "." + ns + "-" + version + ".vsix";
            if (outPath === "{auto}") {
                return path.resolve(autoName);
            }
            else {
                var basename = path.basename(outPath);
                if (basename.indexOf(".") > 0) {
                    return path.resolve(outPath);
                }
                else {
                    return path.resolve(path.join(outPath, autoName));
                }
            }
        };
        VsixWriter.toZipItemName = function (partName) {
            if (_.startsWith(partName, "/")) {
                return partName.substr(1);
            }
            else {
                return partName;
            }
        };
        VsixWriter.prototype.writeVsix = function () {
            var _this = this;
            var outputPath = this.getOutputPath(this.settings.outputPath);
            var vsix = new zip();
            var root = this.vsoManifest.__meta_root;
            if (!root) {
                throw "Manifest root unknown. Manifest objects should have a __meta_root key specifying the absolute path to the root of assets.";
            }
            var overrides = {};
            Object.keys(this.files).forEach(function (file) {
                if (_.endsWith(file, VsixWriter.VSO_MANIFEST_FILENAME)) {
                    return;
                }
                var partName = Merger.cleanAssetPath(_this.files[file].partName);
                var fsPath = path.join(root, file);
                var fContents = null;
                try {
                    fContents = fs.readFileSync(fsPath);
                }
                catch (e) {
                    throw "No such file '" + fsPath + "'. Check the location of this file and update the manifest if necessary.";
                }
                vsix.file(VsixWriter.toZipItemName(partName), fContents);
                if (_this.files[file].contentType) {
                    overrides[partName] = _this.files[file];
                }
            });
            return this.addResourceStrings(vsix).then(function () {
                vsix.file(VsixWriter.toZipItemName(VsixWriter.VSO_MANIFEST_FILENAME), _this.getVsoManifestString(_this.resources.vsoResources));
                vsix.file(VsixWriter.toZipItemName(VsixWriter.VSIX_MANIFEST_FILENAME), _this.getVsixManifestString());
                return _this.genContentTypesXml(Object.keys(vsix.files), overrides).then(function (contentTypesXml) {
                    vsix.file(VsixWriter.toZipItemName(VsixWriter.CONTENT_TYPES_FILENAME), contentTypesXml);
                });
            }).then(function () {
                var builder = new xml.Builder(VsixWriter.DEFAULT_XML_BUILDER_SETTINGS);
                var vsixResourcesXmlStr = builder.buildObject(_this.resources.vsixResources);
                var buffer = vsix.generate({
                    type: "nodebuffer",
                    compression: "DEFLATE"
                });
                log.debug("Writing vsix to: %s", outputPath);
                return Q.nfcall(mkdirp, path.dirname(outputPath))
                    .then(function () { return Q.nfcall(fs.writeFile, outputPath, buffer); })
                    .then(function () { return outputPath; });
            });
        };
        VsixWriter.prototype.getVsoManifestString = function (replacements) {
            var eol = os.EOL;
            var defaultVsoManifest = loc.LocPrep.makeReplacements(this.vsoManifest, replacements, this.resources.vsoResources);
            return JSON.stringify(this.removeMetaKeys(defaultVsoManifest), null, 4).replace(/\n/g, eol);
        };
        VsixWriter.prototype.getVsixManifestString = function () {
            var eol = os.EOL;
            var builder = new xml.Builder(VsixWriter.DEFAULT_XML_BUILDER_SETTINGS);
            return builder.buildObject(this.removeMetaKeys(this.vsixManifest)).replace(/\n/g, eol);
        };
        VsixWriter.prototype.addResourceStrings = function (vsix) {
            var _this = this;
            if (!this.settings.locRoot) {
                return Q.resolve(null);
            }
            var stringsPath = path.resolve(this.settings.root, this.settings.locRoot);
            return Q.Promise(function (resolve, reject, notify) {
                fs.exists(stringsPath, function (exists) {
                    resolve(exists);
                });
            }).then(function (exists) {
                if (exists) {
                    return Q.nfcall(fs.lstat, stringsPath).then(function (stats) {
                        if (stats.isDirectory()) {
                            return true;
                        }
                    });
                }
                else {
                    return Q.resolve(false);
                }
            }).then(function (stringsFolderExists) {
                if (!stringsFolderExists) {
                    return Q.resolve(null);
                }
                return Q.nfcall(fs.readdir, stringsPath).then(function (files) {
                    var promises = [];
                    files.forEach(function (languageTag) {
                        var filePath = path.join(stringsPath, languageTag);
                        var promise = Q.nfcall(fs.lstat, filePath).then(function (fileStats) {
                            if (fileStats.isDirectory()) {
                                var resourcePath = path.join(filePath, "resources.resjson");
                                return Q.Promise(function (resolve, reject, notify) {
                                    fs.exists(resourcePath, function (exists) {
                                        resolve(exists);
                                    });
                                }).then(function (exists) {
                                    if (exists) {
                                        return Q.nfcall(fs.readFile, resourcePath, "utf8").then(function (contents) {
                                            var resourcesObj = JSON.parse(contents);
                                            var locGen = new loc.LocPrep.LocKeyGenerator(null, null);
                                            var splitRes = locGen.splitIntoVsoAndVsixResourceObjs(resourcesObj);
                                            var locManifestPath = languageTag + "/" + VsixWriter.VSO_MANIFEST_FILENAME;
                                            vsix.file(VsixWriter.toZipItemName(locManifestPath), _this.getVsoManifestString(splitRes.vsoResources));
                                            _this.vsixManifest.PackageManifest.Assets[0].Asset.push({
                                                "$": {
                                                    Lang: languageTag,
                                                    Type: "Microsoft.VisualStudio.Services.Manifest",
                                                    Path: locManifestPath,
                                                    Addressable: "true",
                                                    "d:Source": "File"
                                                }
                                            });
                                            var builder = new xml.Builder(VsixWriter.DEFAULT_XML_BUILDER_SETTINGS);
                                            var vsixLangPackStr = builder.buildObject(splitRes.vsixResources);
                                            vsix.file(VsixWriter.toZipItemName(languageTag + "/Extension.vsixlangpack"), vsixLangPackStr);
                                        });
                                    }
                                    else {
                                        return Q.resolve(null);
                                    }
                                });
                            }
                        });
                        promises.push(promise);
                    });
                    return Q.all(promises);
                });
            });
        };
        VsixWriter.prototype.genContentTypesXml = function (fileNames, overrides) {
            var _this = this;
            log.debug("Generating [Content_Types].xml");
            var contentTypes = {
                Types: {
                    $: {
                        xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
                    },
                    Default: [],
                    Override: []
                }
            };
            var windows = /^win/.test(process.platform);
            var contentTypePromise;
            if (windows) {
                var contentTypePromises = [];
                var extensionlessFiles = [];
                var uniqueExtensions = _.unique(fileNames.map(function (f) {
                    var extName = path.extname(f);
                    if (!extName && !overrides[f]) {
                        log.warn("File %s does not have an extension, and its content-type is not declared. Defaulting to application/octet-stream.", path.resolve(f));
                        overrides[f] = { partName: f, contentType: "application/octet-stream" };
                    }
                    if (overrides[f]) {
                        return "";
                    }
                    return extName;
                }));
                uniqueExtensions.forEach(function (ext) {
                    if (!ext.trim()) {
                        return;
                    }
                    if (!ext) {
                        return;
                    }
                    if (VsixWriter.CONTENT_TYPE_MAP[ext.toLowerCase()]) {
                        contentTypes.Types.Default.push({
                            $: {
                                Extension: ext,
                                ContentType: VsixWriter.CONTENT_TYPE_MAP[ext.toLowerCase()]
                            }
                        });
                        return;
                    }
                    var hkcrKey = new winreg({
                        hive: winreg.HKCR,
                        key: "\\" + ext.toLowerCase()
                    });
                    var regPromise = Q.ninvoke(hkcrKey, "get", "Content Type").then(function (type) {
                        log.debug("Found content type for %s: %s.", ext, type.value);
                        var contentType = "application/octet-stream";
                        if (type) {
                            contentType = type.value;
                        }
                        return contentType;
                    }).catch(function (err) {
                        log.warn("Could not determine content type for extension %s. Defaulting to application/octet-stream. To override this, add a contentType property to this file entry in the manifest.", ext);
                        return "application/octet-stream";
                    }).then(function (contentType) {
                        contentTypes.Types.Default.push({
                            $: {
                                Extension: ext,
                                ContentType: contentType
                            }
                        });
                    });
                    contentTypePromises.push(regPromise);
                });
                contentTypePromise = Q.all(contentTypePromises);
            }
            else {
                var contentTypePromises = [];
                var extTypeCounter = {};
                fileNames.forEach(function (fileName) {
                    var extension = path.extname(fileName);
                    var mimePromise;
                    if (VsixWriter.CONTENT_TYPE_MAP[extension]) {
                        if (!extTypeCounter[extension]) {
                            extTypeCounter[extension] = {};
                        }
                        if (!extTypeCounter[extension][VsixWriter.CONTENT_TYPE_MAP[extension]]) {
                            extTypeCounter[extension][VsixWriter.CONTENT_TYPE_MAP[extension]] = [];
                        }
                        extTypeCounter[extension][VsixWriter.CONTENT_TYPE_MAP[extension]].push(fileName);
                        mimePromise = Q.resolve(null);
                        return;
                    }
                    mimePromise = Q.Promise(function (resolve, reject, notify) {
                        var child = childProcess.exec("file --mime-type \"" + fileName + "\"", function (err, stdout, stderr) {
                            try {
                                if (err) {
                                    reject(err);
                                }
                                var stdoutStr = stdout.toString("utf8");
                                var magicMime = _.trimRight(stdoutStr.substr(stdoutStr.lastIndexOf(" ") + 1), "\n");
                                log.debug("Magic mime type for %s is %s.", fileName, magicMime);
                                if (magicMime) {
                                    if (extension) {
                                        if (!extTypeCounter[extension]) {
                                            extTypeCounter[extension] = {};
                                        }
                                        var hitCounters = extTypeCounter[extension];
                                        if (!hitCounters[magicMime]) {
                                            hitCounters[magicMime] = [];
                                        }
                                        hitCounters[magicMime].push(fileName);
                                    }
                                    else {
                                        if (!overrides[fileName]) {
                                            overrides[fileName].contentType = magicMime;
                                        }
                                    }
                                }
                                else {
                                    if (stderr) {
                                        reject(stderr.toString("utf8"));
                                    }
                                    else {
                                        log.warn("Could not determine content type for %s. Defaulting to application/octet-stream. To override this, add a contentType property to this file entry in the manifest.", fileName);
                                        overrides[fileName].contentType = "application/octet-stream";
                                    }
                                }
                                resolve(null);
                            }
                            catch (e) {
                                reject(e);
                            }
                        });
                    });
                    contentTypePromises.push(mimePromise);
                });
                contentTypePromise = Q.all(contentTypePromises).then(function () {
                    Object.keys(extTypeCounter).forEach(function (ext) {
                        var hitCounts = extTypeCounter[ext];
                        var bestMatch = _this.maxKey(hitCounts, (function (i) { return i.length; }));
                        Object.keys(hitCounts).forEach(function (type) {
                            if (type === bestMatch) {
                                return;
                            }
                            hitCounts[type].forEach(function (fileName) {
                                overrides[fileName].contentType = type;
                            });
                        });
                        contentTypes.Types.Default.push({
                            $: {
                                Extension: ext,
                                ContentType: bestMatch
                            }
                        });
                    });
                });
            }
            return contentTypePromise.then(function () {
                Object.keys(overrides).forEach(function (partName) {
                    contentTypes.Types.Override.push({
                        $: {
                            ContentType: overrides[partName].contentType,
                            PartName: "/" + _.trimLeft(partName, "/")
                        }
                    });
                });
                var builder = new xml.Builder(VsixWriter.DEFAULT_XML_BUILDER_SETTINGS);
                return builder.buildObject(contentTypes).replace(/\n/g, os.EOL);
            });
        };
        VsixWriter.prototype.removeMetaKeys = function (obj) {
            return _.omit(obj, function (v, k) {
                return _.startsWith(k, "__meta_");
            });
        };
        VsixWriter.prototype.maxKey = function (obj, func) {
            var maxProp;
            for (var prop in obj) {
                if (!maxProp || func(obj[prop]) > func(obj[maxProp])) {
                    maxProp = prop;
                }
            }
            return maxProp;
        };
        VsixWriter.VSO_MANIFEST_FILENAME = "extension.vsomanifest";
        VsixWriter.VSIX_MANIFEST_FILENAME = "extension.vsixmanifest";
        VsixWriter.CONTENT_TYPES_FILENAME = "[Content_Types].xml";
        VsixWriter.DEFAULT_XML_BUILDER_SETTINGS = {
            indent: "    ",
            newline: os.EOL,
            pretty: true,
            xmldec: {
                encoding: "utf-8",
                standalone: null,
                version: "1.0"
            }
        };
        VsixWriter.CONTENT_TYPE_MAP = {
            ".md": "text/markdown",
            ".pdf": "application/pdf",
            ".png": "image/png",
            ".jpeg": "image/jpeg",
            ".jpg": "image/jpeg",
            ".gif": "image/gif",
            ".bat": "application/bat",
            ".json": "application/json",
            ".vsixlangpack": "text/xml",
            ".vsixmanifest": "text/xml",
            ".vsomanifest": "application/json",
            ".ps1": "text/ps1"
        };
        return VsixWriter;
    })();
    Package.VsixWriter = VsixWriter;
})(Package = exports.Package || (exports.Package = {}));
